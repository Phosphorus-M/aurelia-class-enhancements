<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl">
  <title data-ice="title">Home | aurelia-class-enhancements</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Enhance your Aurelia&apos;s classes with high order functionality"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="aurelia-class-enhancements"><meta property="twitter:description" content="Enhance your Aurelia&apos;s classes with high order functionality"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/aurelia-class-enhancements"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-enhance">enhance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-EnhancementCreator">EnhancementCreator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Class</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><div data-ice="index" class="github-markdown"><h1 id="aurelia-class-enhancements">aurelia-class-enhancements</h1><p><a href="https://travis-ci.org/homer0/aurelia-class-enhancements"><img src="https://img.shields.io/travis/homer0/aurelia-class-enhancements.svg?style=flat-square" alt="Travis"></a>
<a href="https://coveralls.io/github/homer0/aurelia-class-enhancements?branch=master"><img src="https://img.shields.io/coveralls/github/homer0/aurelia-class-enhancements.svg?style=flat-square" alt="Coveralls github"></a>
<a href="https://david-dm.org/homer0/aurelia-class-enhancements"><img src="https://img.shields.io/david/dev/homer0/aurelia-class-enhancements.svg?style=flat-square" alt="David"></a></p>
<p>Enhance your Aurelia&apos;s classes with high order functionality</p>
<h2 id="introduction">Introduction</h2><blockquote>
<p>If you are wondering why I built this, go to the <a href="#motivation">Motivation</a> section.</p>
</blockquote>
<p>Here&apos;s a really basic example of what you can achieve using this library:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">// myComponent.js
import enhance from &apos;aurelia-class-enhancements&apos;;
import LogStatus from &apos;./logStatus&apos;;

@enhance(LogStatus)
class MyComponent {}

export { MyComponent };

// logStatus.js
class LogStatus {
  attached() {
    console.log(&apos;attached :D!&apos;);
  }
  detached() {
    console.log(&apos;detached D:!&apos;);
  }
}</code>
</code></pre>
<p>When your component gets attached to the DOM (or gets detached), via the enhancement class <code>LogStatus</code>, it will log a message on the console; all of this without having to write the functionality on your component class and without needing class inheritance.</p>
<h2 id="usage">Usage</h2><p>As you saw on the example above, the way it works is pretty straightforward:</p>
<ol>
<li>Define an enhancement class with methods you want to be called when the ones of the target class are triggered.</li>
<li>Add the enhancement to the target class using the <code>enhance</code> decorator.</li>
</ol>
<h3 id="access-the-target-class">Access the target class</h3><p>When instantiating an enhancement, the library sends to a reference of the target class instance to the enhancement constructor, so you can access methods and properties on your custom methods.</p>
<p>Let&apos;s say you have a component that renders a form where the user saves some important information, and if the user were to leave the route without saving the information, you would want to use a prompt to ask for confirmation.</p>
<p>A basic approach would be to have a flag indicating if the changes are saved and then use the <code>canDeactivate</code> lifecycle method to decide whether to show the prompt or not:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">class MyForm {
  isSaved = false;
  ...
  canDeactivate() {
    // If everything is saved, go away.
    if (isSaved) {
      return true;
    }

    // Let&apos;s make the prompt async.
    return new Promise((resolve) =&gt; {
      // ask for the user confirmation.
      const answer = confirm(&apos;Confirm that you want to leave without saving&apos;);
      // resolve the promise with the answer.
      resolve(answer);
    });
  }
}

export { MyForm };</code>
</code></pre>
<p>It works, is simple and you didn&apos;t have to involve any external logic. But now, what if you have to implement this same logic on four more forms? That&apos;s when an enhancement is useful.</p>
<p>Let&apos;s write an enhancement that uses the reference for the ViewModel in order to verify if the user needs to be prompted.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">class FormConfirmation {
  constructor(viewModel) {
    this._viewModel = viewModel;
  }

  canDeactivate() {
    if (this._viewModel.isSaved) {
      return true;
    }

    return new Promise((resolve) =&gt; {
      const answer = confirm(&apos;Confirm that you want to leave without saving&apos;);
      resolve(answer);
    });
  }
}</code>
</code></pre>
<p>It&apos;s the same functionality, but it now checks the <code>isSaved</code> property form the ViewModel.</p>
<blockquote>
<p>In this case it was really easy because the property is a <code>boolean</code> and the <code>if</code> checks with <em>falsy</em>, but we could&apos;ve check if the property was defined and use a different default, like &quot;if the ViewModel doesn&apos;t have the property, the user can always leave without confirmation&quot;.</p>
</blockquote>
<p>Ok, let&apos;s add it to the form:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import enhance from &apos;aurelia-class-enhancements&apos;;
import { FormConfirmation } from &apos;...&apos;;

@enhance(FormConfirmation)
class MyForm {
  isSaved = false;
  ...
}

export { MyForm };</code>
</code></pre>
<p>And that&apos;s all, you can now add it to the other four forms using the enhancement.</p>
<h3 id="dependency-injection">Dependency injection</h3><p>Just like on any other class you use in the Aurelia context, you can use the <code>@inject</code> decorator on an enhancement in order to inject dependencies.</p>
<p>We&apos;ll use the enhancement from the first example and trigger an event before the log messages.</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { inject } from &apos;aurelia-framework&apos;;
import { EventAggregator } from &apos;aurelia-event-aggregator&apos;;

@inject(EventAggregator);
class LogStatus {
  constructor(viewModel, ea) {
    this._viewModel = viewModel;
    this._ea = ea;
  }
  attached() {
    this._ea.publish(&apos;something:attached&apos;, this._viewModel);
    console.log(&apos;attached :D!&apos;);
  }
  detached() {
    this._ea.publish(&apos;something:detached&apos;, this._viewModel);
    console.log(&apos;detached D:!&apos;);
  }
}</code>
</code></pre>
<blockquote>
<p>This is the feature that makes this library Aurelia-specific.</p>
</blockquote>
<h3 id="enhance-an-enhancement">Enhance an enhancement</h3><p>Since the library was made to enhance any kind of class, that means that you could also enhance an enhancement class.</p>
<p>Let&apos;s take the example about dependency injection and move the events part to another enhancement:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import { inject } from &apos;aurelia-framework&apos;;
import { EventAggregator } from &apos;aurelia-event-aggregator&apos;;

@inject(EventAggregator);
class PublishStatus {
  constructor(viewModel, ea) {
    this._viewModel = viewModel;
    this._ea = ea;
  }
  attached() {
    this._ea.publish(&apos;something:attached&apos;, this._viewModel);
  }
  detached() {
    this._ea.publish(&apos;something:detached&apos;, this._viewModel);
  }
}

export { PublishStatus };</code>
</code></pre>
<p>Now we can create an enhanced <code>LogStatus</code> with <code>PublishStatus</code>:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import enhance from &apos;aurelia-class-enhancements&apos;;
import { PublishStatus } from &apos;...&apos;;

@enhance(PublishStatus)
class LogStatus {
  attached() {
    console.log(&apos;attached :D!&apos;);
  }
  detached() {
    console.log(&apos;detached D:!&apos;);
  }
}</code>
</code></pre>
<p>That was just to prove the point that you can enhance an enhancement, but there are two other, and simpler, ways in which you can achieve the same result:</p>
<h4 id="the-decorator-as-a-function">The decorator as a function</h4><p>Decorators are just functions, in this case, a function that returns a function:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">enhance(...Enhancements)(TargetClass): Proxy&lt;TargetClass&gt;</code>
</code></pre>
<p>So, instead of enhancing <code>LogStatus</code> with <code>PublishStatus</code>, we can create a new enhancement with both of them:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import enhance from &apos;aurelia-class-enhancements&apos;;
import { LogStatus } from &apos;...&apos;;
import { PublishStatus } from &apos;...&apos;;

export const PublishAndLogStatus = enhance(PublishStatus)(LogStatus);</code>
</code></pre>
<h4 id="multiple-enhancements-at-once">Multiple enhancements at once</h4><p>The <code>enhance</code> decorator supports multiple enhancements as parameters, so we could just send <code>LogStatus</code> and then <code>PublishStatus</code> to the class with want to enhance and the result would be the same:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">import enhance from &apos;aurelia-class-enhancements&apos;;
import { LogStatus } from &apos;...&apos;;
import { PublishStatus } from &apos;...&apos;;

@enhance(LogStatus, PublishStatus)
class MyComponent {}</code>
</code></pre>
<h3 id="lifecycle-method">Lifecycle method</h3><p>Let&apos;s say we have this enhancement:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">class FormConfirmation {
  constructor(viewModel) {
    this._viewModel = viewModel;
  }

  canDeactivate() {
    if (this._viewModel.isSaved) {
      return true;
    }

    return new Promise((resolve) =&gt; {
      const answer = confirm(&apos;Confirm that you want to leave without saving&apos;);
      resolve(answer);
    });
  }
}</code>
</code></pre>
<p>But on the ViewModel, you want to add some other functionality that also needs to run on the <code>canDeactivate</code>, but only if the enhanced method returned <code>false</code>.</p>
<p>Modifying the signature of the enhanced method to add an extra parameter wasn&apos;t an option, as it could end up messing up methods with optional parameters.</p>
<p>The easiest way to solve this was adding a <em>lifecycle method</em> the library will call, if defined, with whatever was returned from the enhanced method.</p>
<p>The name of the method is dynamically generated based on the name of the original method: <code>enhanced[OriginalMethodName]Return</code> (even if the method name starts with lowercase, the library will make the first letter uppercase).</p>
<p>This is its signature:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">enhancedCanDeactivateReturn(value, enhancementInstance): void</code>
</code></pre>
<h2 id="development">Development</h2><h3 id="npm-yarn-tasks">NPM/Yarn tasks</h3><table>
<thead>
<tr>
<th>Task</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>test</code></td>
<td>Run the project unit tests.</td>
</tr>
<tr>
<td><code>lint</code></td>
<td>Lint the modified files.</td>
</tr>
<tr>
<td><code>lint:all</code></td>
<td>Lint the entire project code.</td>
</tr>
<tr>
<td><code>docs</code></td>
<td>Generate the project documentation.</td>
</tr>
<tr>
<td><code>todo</code></td>
<td>List all the pending to-do&apos;s.</td>
</tr>
</tbody>
</table>
<h3 id="repository-hooks">Repository hooks</h3><p>I use <a href="https://yarnpkg.com/en/package/husky">husky</a> to automatically install the repository hooks so the code will be tested and linted before any commit and the dependencies updated after every merge. The configuration is on the <code>husky</code> property of the <code>package.json</code> and the hooks&apos; files are on <code>./utils/hooks</code>.</p>
<h3 id="testing">Testing</h3><p>I use <a href="https://facebook.github.io/jest/">Jest</a> with <a href="https://yarnpkg.com/en/package/jest-ex">Jest-Ex</a> to test the project. The configuration file is on <code>./.jestrc.json</code>, the tests are on <code>./tests</code> and the script that runs it is on <code>./utils/scripts/test</code>.</p>
<h3 id="linting">Linting</h3><p>I use <a href="http://eslint.org">ESlint</a> with <a href="http://yarnpkg.com/en/package/eslint-plugin-homer0">my own custom configuration</a> to validate all the JS code. The configuration file for the project code is on <code>./.eslintrc</code> and the one for the tests is on <code>./tests/.eslintrc</code>. There&apos;s also an <code>./.eslintignore</code> to exclude some files on the process. The script that runs it is on <code>./utils/scripts/lint</code>.</p>
<h3 id="documentation">Documentation</h3><p>I use <a href="http://esdoc.org">ESDoc</a> to generate HTML documentation for the project. The configuration file is on <code>./.esdoc.json</code> and the script that runs it is on <code>./utils/scripts/docs</code>.</p>
<h3 id="to-dos">To-Dos</h3><p>I use <code>@todo</code> comments to write all the pending improvements and fixes, and <a href="https://yarnpkg.com/en/package/leasot">Leasot</a> to generate a report. The script that runs it is on <code>./utils/scripts/todo</code>.</p>
<h2 id="motivation">Motivation</h2><blockquote>
<p>I put this at the end because no one usually reads it :P.</p>
</blockquote>
<p>The example about prompting the user when there&apos;s a form unsaved was a real case requirement for me, and while discussing which would be the best approach to implement it, there were three conclusions:</p>
<ol>
<li>OOP inheritance on the ViewModels sounds like a terrible idea; and you are limited to only one &quot;enhancement&quot;.</li>
<li>Mixins on &quot;real classes&quot; was a no-go.</li>
<li>It should be something like React&apos;s high order components (I know high order functionality is not specific to React, but that&apos;s where it shines).</li>
</ol>
<p>So, I wanted something similar to React&apos;s HOCs, but for classes, and a little bit closer to a HOF (function), since there&apos;s no JSX on Aurelia.</p>
<p>Lately, I&apos;ve been playing around with Proxies on some of my other libraries, and they are <strong>really powerful</strong>; so I thought I could use a proxy on top of a class and the only complicated part would be to solve the dependency injection, as I wanted the enhancements to be able to access other services.</p>
<p>I got a prototype working and that&apos;s when I realized that Aurelia makes &quot;heavy use&quot; of decorators, so instead of having a function to enhance the class before exporting it (like the React approach), I could &quot;decorate the class&quot;:</p>
<pre><code class="lang-js"><code class="source-code prettyprint">@enhance(MyEnhancement)
class MyComponent {}</code>
</code></pre>
<p>Yay :D!</p>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
