<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/index.js | aurelia-class-enhancements</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Enhance your Aurelia&apos;s classes with high order functionality"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="aurelia-class-enhancements"><meta property="twitter:description" content="Enhance your Aurelia&apos;s classes with high order functionality"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/aurelia-class-enhancements"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-enhance">enhance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-EnhancementCreator">EnhancementCreator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Class</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * @external {Class} https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
 */

/**
 * @typedef {function} EnhancementCreator
 * @param {Class} Target The class to enhance.
 * @return {Proxy&lt;Class&gt;} A proxied version of the `Target`.
 */

/**
 * @typedef {function} GetDependencies
 * @param {Array} list All the dependencies Aurelia returned, for both the target class and the
 *                     enhancement class.
 * @return {Array} A list of dependencies for the requested case, be the target class or the
 *                 enhancement class.
 * @ignore
 */

/**
 * These are necessary resources for the `isNativeFn` function.
 * @ignore
 */
const { toString } = Object.prototype;
/**
 * @ignore
 */
const { toString: fnToString } = Function.prototype;
/**
 * @ignore
 */
const reBase = String(toString)
.replace(/[.*+?^${}()|[\]\/\\]/g, &apos;\\$&amp;&apos;)
.replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, &apos;$1.*?&apos;);
/**
 * @ignore
 */
const reNative = RegExp(`^${reBase}$`);
/**
 * Checks whether a function is native or not.
 * @param {function} fn The function to validate.
 * @return {Boolean}
 * @see https://davidwalsh.name/detect-native-function
 * @ignore
 */
const isNativeFn = (fn) =&gt; fnToString.call(fn).match(reNative);
/**
 * This utility function takes care of generating a unique list of dependencies for both, the
 * target and the class that enhances it. It then provides methods to extract the dependencies
 * of each one when Aurelia is done instantiating them.
 * @param {Array} [target=[]]      The list of dependencies for the target class.
 * @param {Array} [enhancement=[]] The list of dependencies for the enhance class.
 * @return {Object}
 * @property {Array}           list              The unique list of all the dependencies both
 *                                               classes need.
 * @property {GetDependencies} getForTarget      Given the list of all the obtained dependencies,
 *                                               it filters the ones needed for the target
 *                                               class.
 * @property {GetDependencies} getForEnhancement Given the list of all the obtained dependencies,
 *                                               it filters the ones needed for the enhancement
 *                                               class.
 * @ignore
 */
const getInjectData = (target = [], enhancement = []) =&gt; {
  const list = target.slice();
  const enhancementPositions = {};
  enhancement.forEach((dep) =&gt; {
    const targetIndex = list.indexOf(dep);
    if (targetIndex &gt; -1) {
      enhancementPositions[dep] = targetIndex;
    } else {
      list.push(dep);
      enhancementPositions[dep] = list.length - 1;
    }
  });

  return {
    list,
    getForTarget: (values) =&gt; values.slice(0, target.length),
    getForEnhancement: (values) =&gt; enhancement.map((dep) =&gt; (
      values[enhancementPositions[dep]]
    )),
  };
};
/**
 * This is called from the proxy created on {@link enhanceInstance} when the enhancement
 * implements a method of the target that is being requested.
 * The function will first call the enhanced method, then evaluate whether it should resolved as
 * a promise (becuase the method returned a `Promise`) or sync, check if the target implements
 * the lifecycle method to recive what the enhancement returned and finally, call the original
 * method.
 * @param {Object}  target      The target class instance.
 * @param {Object}  enhancement The instance with the enhanced methods.
 * @param {String}  name        The name of the method being requested.
 * @param {Boolean} callTarget  Whether or not the target method should be called.
 * @return {Function} A version of the method that calls both, the enhancement and the original.
 * @ignore
 */
const composeMethod = (target, enhancement, name, callTarget) =&gt; (...args) =&gt; {
  const enhancedMethod = enhancement[name];
  const enhancedValue = enhancedMethod(...args);
  const normalizedName = name.replace(/^[a-z]/, (match) =&gt; match.toUpperCase());
  const lcMethodName = `enhanced${normalizedName}Return`;
  const hasLCMethod = typeof target[lcMethodName] === &apos;function&apos;;
  let result;
  const isPromise = enhancedValue &amp;&amp; typeof enhancedValue.then === &apos;function&apos;;
  if (isPromise) {
    result = enhancedValue.then((value) =&gt; {
      if (hasLCMethod) {
        target[lcMethodName](value, enhancement);
      }

      return callTarget ? target[name](...args) : value;
    });
  } else {
    if (hasLCMethod) {
      target[lcMethodName](enhancedValue, enhancement);
    }

    result = callTarget ? target[name](...args) : enhancedValue;
  }

  return result;
};
/**
 * Creates a proxy for a target class instance so when a method is called, it will check if the
 * enhancement class implements its in order to trigger that one before the original.
 * @param {Object} target      The target class instance to proxy.
 * @param {Object} enhancement The instance that will add methods to the target class.
 * @return {Object} A proxied version of the `target`.
 * @ignore
 */
const enhanceInstance = (target, enhancement) =&gt; new Proxy(target, {
  get: (targetCls, name) =&gt; {
    let result;
    const targetValue = targetCls[name];
    const targetIsFn = typeof targetValue === &apos;function&apos;;
    const enhancementValue = enhancement[name];
    const enhancementIsFn = typeof enhancementValue === &apos;function&apos;;
    if (targetIsFn &amp;&amp; isNativeFn(targetValue)) {
      result = targetValue;
    } else if (enhancementIsFn) {
      result = composeMethod(targetCls, enhancement, name, targetIsFn);
    } else {
      result = targetValue;
    }

    return result;
  },
});
/**
 * Creates a proxy from a target class declaration in order to:
 * 1. Concatenate the list of dependencies both classes need.
 * 2. Instance both the target and the enhancement classes, sending the right dependencies.
 * @param {Class} Target      The target class to proxy.
 * @param {Class} Enhancement The class that will add methods to the target.
 * @return {Class} A proxied version of the `Target`.
 * @ignore
 */
const proxyClass = (Target, Enhancement) =&gt; {
  const injectData = getInjectData(Target.inject, Enhancement.inject);
  return new Proxy(Target, {
    construct: (TargetCls, args) =&gt; {
      const targetInstance = new TargetCls(...injectData.getForTarget(args));
      const enhancementInstance = new Enhancement(
        targetInstance,
        ...injectData.getForEnhancement(args)
      );

      return enhanceInstance(targetInstance, enhancementInstance);
    },
    get: (target, name) =&gt; (
      name === &apos;inject&apos; ?
        injectData.list :
        target[name]
    ),
  });
};
/**
 * Creates a function to enhance an Aurelia&apos;s class with other class(es).
 * This method has this sintax because is intended to be used as a decorator.
 * @example
 * &lt;caption&gt;As decorator&lt;/caption&gt;
 * \@enhance(MyEnhancement)
 * class MyViewModel { ... }
 * @example
 * &lt;caption&gt;As function:&lt;/caption&gt;
 * enhance(MyEnhancement)(MyViewModel)
 * @param {...Class} enhancements The class or list of classes to enhance the target.
 * @return {EnhancementCreator}
 */
const enhance = (...enhancements) =&gt; (Target) =&gt; enhancements.reduce(
  (Current, Enhancement) =&gt; proxyClass(Current, Enhancement),
  Target
);

module.exports = enhance;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
